<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | 4Fun</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just For Fun">
    
    <link rel="preload" href="/vpTST/assets/css/0.styles.7fc12ffc.css" as="style"><link rel="preload" href="/vpTST/assets/js/app.964cbb8c.js" as="script"><link rel="preload" href="/vpTST/assets/js/3.86ab0857.js" as="script"><link rel="preload" href="/vpTST/assets/js/1.84cb0844.js" as="script"><link rel="preload" href="/vpTST/assets/js/9.8592346e.js" as="script"><link rel="prefetch" href="/vpTST/assets/js/10.31e1e33a.js"><link rel="prefetch" href="/vpTST/assets/js/11.ad727044.js"><link rel="prefetch" href="/vpTST/assets/js/12.ddd3bb3d.js"><link rel="prefetch" href="/vpTST/assets/js/4.71a4996e.js"><link rel="prefetch" href="/vpTST/assets/js/5.6313599f.js"><link rel="prefetch" href="/vpTST/assets/js/6.e9742c29.js"><link rel="prefetch" href="/vpTST/assets/js/7.66f3f668.js"><link rel="prefetch" href="/vpTST/assets/js/8.9c0d15a3.js">
    <link rel="stylesheet" href="/vpTST/assets/css/0.styles.7fc12ffc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>4Fun</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>Just For Fun</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vpTST/" class="home-link router-link-active"><!----> <span class="site-name">4Fun</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vpTST/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      ts blog
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>3</h3> <h6 data-v-39576ba9>Articles</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>Tags</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/vpTST/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      ts blog
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/vpTST/" class="sidebar-heading clickable router-link-active"><span>hihihi</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vpTST/" aria-current="page" class="sidebar-link">index</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/vpTST/H5C3JS/H5C3" class="sidebar-heading clickable open"><span>H5C3</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vpTST/H5C3JS/H5C3.html" class="sidebar-link">H5C3</a></li><li><a href="/vpTST/H5C3JS/JS.html" aria-current="page" class="active sidebar-link">JS</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>JS</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">JS</h1> <div data-v-f875f3fc><i class="iconfont reco-account" data-v-f875f3fc><span data-v-f875f3fc>ts</span></i> <i class="iconfont reco-date" data-v-f875f3fc><span data-v-f875f3fc>3/21/2022</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="js"><a href="#js" class="header-anchor">#</a> JS</h1> <p>javaScript三部分</p> <p>ECMAScript+DOM+BOM</p> <p>动态语言，不确定变量类型，在代码执行过程中，可以随意修改</p> <p>var name=&quot;abc&quot;;		//string类型</p> <p>name=123;			//整型</p> <p>编译性语言：</p> <p>​	先编译再运行</p> <p>​	c／c++／Objective-C／...</p> <p>解释性语言：</p> <p>​	边读边运行</p> <p>​	Python/JavaScript/MATLAB</p> <p>书写位置</p> <p>html标签里</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;a href=&quot;&quot; onclick=&quot;alert('弹窗')&quot;&gt;弹窗&lt;/a&gt;
</code></pre></div><p>body里</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
	alert('弹窗');
&lt;/script&gt;
</code></pre></div><p>外部引入</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;./js/test.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p>#4_变量、作用域、内存</p> <p>编写代码存储在硬盘中，</p> <p>代码在内存中执行，内存有栈空间堆空间，</p> <p>基本数据类型在栈空间分配，</p> <p>对象类型在堆空间，栈空间指针指向堆空间</p> <h2 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h2> <p>变量包括两种不同的类型：原始值和引用值</p> <p>原始值就是最简单的数据，保存原始值的变量是按值访问的</p> <p>​	Undefined、Null、Boolean、Number、String、Symbol</p> <p>引用值：多个值构成的对象，保存在内存中，js不能直接访问内存位置，实际操作的是该对象的引用，保存引用值的变量按照引用访问</p> <p>​	Array、object</p> <h2 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h2> <p>JS为每段可执行代码创建其执行上下文</p> <p>可执行代码：全局代码、函数代码、eval代码</p> <p>所以就有：全局上下文、函数上下文</p> <p>函数被调用执行就会创建这个函数的执行上下文，这个函数的执行上下文会被推到执行上下文栈上</p> <p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数(全局上下文在应用程 退出前才会被销毁，比如关闭网页或退出浏览器)。</p> <p>每个执行上下文的都有三个重要属性：</p> <p>变量对象</p> <p>作用域链</p> <p>this</p> <h3 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h3> <p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链(scope chain)。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。 。</p> <p>查找变量会从当前上下文的变量对象去查找，如果没找到就去父级作用域查找，一直查找到全局上下文中的变量对象</p> <p>这么一个查找过程形成的链条就叫做作用域链。</p> <h3 id="全局上下文"><a href="#全局上下文" class="header-anchor">#</a> 全局上下文</h3> <p>在浏览器中，全局上下文就是我们常说的 window 对象</p> <h3 id="函数上下文"><a href="#函数上下文" class="header-anchor">#</a> 函数上下文</h3> <p>函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文，形成了个闭包。</p> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <p>隔离变量，不同作用域下的同名变量不会有冲突</p> <div class="language- extra-class"><pre class="language-text"><code>var a=1;
function aa() {
	var a=2;
	var b=3;
	console.log(a);
	console.log(b);
  function bb() {
    var a=2;
    var b=3;
    console.log(a);
    console.log(b);
  }
}
console.log(a)			//1
console.log(aa())			//2 3
console.log(bb())		//error：bb not defined aa没调用


</code></pre></div><p>var只有函数作用域和全局作用域</p> <p>可以重新声明</p> <div class="language- extra-class"><pre class="language-text"><code>let user;
let user; //error

var user=&quot;pete&quot;
var user=&quot;john&quot;		
</code></pre></div><h2 id="静态词法作用域-动态作用域"><a href="#静态词法作用域-动态作用域" class="header-anchor">#</a> 静态词法作用域／动态作用域</h2> <p>静态词法：函数作用域在定义时决定</p> <p>动态作用域：函数作用域在调用时决定</p> <h1 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h1> <p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures</p> <div class="language- extra-class"><pre class="language-text"><code>						  typeof						instanceof			Object.prototype.toString.call()
原始值
undefined     undefined													[object undefined]
Boolean				boolean														[object Boolean]
Number				number														[object Number]
String				string														[object String]
Bigint				bigint														[object Bigint]
Symbol				symbol														[object Symbol]
Null					object														[object Null]


引用值
object				Object						true/false			[object Object]
 Array 		    object						true/false			[object Array]
 Date 				object						true/false			[object Date]
 Function			Function					true/false			[object Function]
</code></pre></div><p>###数据类型</p> <p>####Number</p> <p>数值类型,整数浮点数二进制八进制十六进制都是Number类型</p> <p>NaN</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(NaN == NaN); // false
</code></pre></div><p>对NaN,Not a Number一个特殊数值，计算没有返回值时，返回NaN</p> <p>​	console.log(&quot;number&quot;)</p> <p>​	isNaN 判断是否不是一个数字，不是数字为true，是为false</p> <p>####String</p> <p>单双引号都可，多用双引号</p> <p>打印文本，文本中有双引号</p> <div class="language- extra-class"><pre class="language-text"><code>	console.log('string &quot;string&quot;');
</code></pre></div><p>打印文本，文本中有双引号双引号,转义字符\</p> <div class="language- extra-class"><pre class="language-text"><code>	console.log('string \&quot;\'string ');
	\\	转义\
	\&quot;	转义&quot;
	\t 	转义tab
	\n	转义换行
	
</code></pre></div><p>字符串长度</p> <div class="language- extra-class"><pre class="language-text"><code>var name=&quot;tensoul&quot;;

console.log(name.length);
</code></pre></div><p>####Boolean</p> <p>true flase</p> <div class="language- extra-class"><pre class="language-text"><code>var isLogin=true;

console.log(isLogin);
</code></pre></div><p>####Null</p> <p>null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回&quot;object&quot;的原因:</p> <p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值</p> <p>undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，用等于操作符(==)比较 null 和 undefined 始终返回 true</p> <p>只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(null == undefined);  // true
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>var info={name:&quot;name1&quot;,age:19};

info=null;		一个对象不再使用可以赋值null
</code></pre></div><p>####Undefined</p> <div class="language- extra-class"><pre class="language-text"><code>var flag;

console.log(flag);

一个变量申明了，没赋值，默认为undefined
</code></pre></div><p>undefined由null衍生</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(undefined==null);			//true
</code></pre></div><h3 id="array"><a href="#array" class="header-anchor">#</a> array</h3> <h4 id="元素操作方法"><a href="#元素操作方法" class="header-anchor">#</a> 元素操作方法</h4> <ul><li><code>arr.push(...items)</code> —— 从尾端添加元素，</li> <li><code>arr.pop()</code> —— 从尾端提取元素，</li> <li><code>arr.shift()</code> —— 从首端提取元素，</li> <li><code>arr.unshift(...items)</code> —— 从首端添加元素。</li></ul> <h4 id="搜索方法-查找某值"><a href="#搜索方法-查找某值" class="header-anchor">#</a> 搜索方法：查找某值</h4> <h5 id="arr-indexof"><a href="#arr-indexof" class="header-anchor">#</a> arr.indexOf()</h5> <p><code>arr.indexOf(item, from)</code></p> <p>从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</p> <h5 id="arr-lastindexof"><a href="#arr-lastindexof" class="header-anchor">#</a> arr.lastIndexOf()</h5> <p><code>arr.lastIndexOf(item, from)</code> ：从数组末from 位置开始查找item，返回其index</p> <p>—— 和上面相同，只是从右向左搜索。</p> <h5 id="arr-include"><a href="#arr-include" class="header-anchor">#</a> arr.include()</h5> <p><code>arr.includes(item, from)</code> ：判断数组内是否有item</p> <p>—— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>（译注：如果没找到，则返回 <code>false</code>）。</p> <p><code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">NaN</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1（应该为 0，但是严格相等 === equality 对 NaN 无效）</span>
<span class="token function">alert</span><span class="token punctuation">(</span> arr<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true（这个结果是对的）</span>

</code></pre></div><h4 id="arr-find"><a href="#arr-find" class="header-anchor">#</a> arr.find()</h4> <p>语法如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果返回 true，则返回 item 并停止迭代</span>
  <span class="token comment">// 对于假值（falsy）的情况，则返回 undefined</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>依次对数组中的每个元素调用该函数：</p> <ul><li><code>item</code> 是元素。</li> <li><code>index</code> 是它的索引。</li> <li><code>array</code> 是数组本身。</li></ul> <p>如果它返回 <code>true</code>，则搜索停止，并返回 <code>item</code>。如果没有搜索到，则返回 <code>undefined</code>。</p> <p>例如，我们有一个存储用户的数组，每个用户都有 <code>id</code> 和 <code>name</code> 字段。让我们找到 <code>id == 1</code> 的那个用户：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> users <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Pete&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Mary&quot;</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> user <span class="token operator">=</span> users<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span>

</code></pre></div><h4 id="操作方法"><a href="#操作方法" class="header-anchor">#</a> 操作方法</h4> <h5 id="arr-map"><a href="#arr-map" class="header-anchor">#</a> arr.map()</h5> <p>它对数组的每个元素都调用函数，并返回结果数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回新值而不是当前元素</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//将每个元素转换为它的字符串长度</span>
<span class="token keyword">let</span> lengths <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Bilbo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Gandalf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Nazgul&quot;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>lengths<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5,7,6</span>

</code></pre></div><h5 id="arr-slice"><a href="#arr-slice" class="header-anchor">#</a> arr.slice</h5> <p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p> <div class="language- extra-class"><pre class="language-text"><code>arr.slice([start], [end])

let arr = [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;];

alert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）

alert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）

</code></pre></div><h5 id="arr-filter"><a href="#arr-filter" class="header-anchor">#</a> arr.filter</h5> <p><code>filter</code> 返回的是所有匹配元素组成的数组</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> results <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果 true item 被 push 到 results，迭代继续</span>
  <span class="token comment">// 如果什么都没找到，则返回空数组</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> users <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Pete&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Mary&quot;</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 返回前两个用户的数组</span>
<span class="token keyword">let</span> someUsers <span class="token operator">=</span> users<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item<span class="token punctuation">.</span>id <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>someUsers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>


</code></pre></div><h5 id="arr-reduce"><a href="#arr-reduce" class="header-anchor">#</a> arr.reduce</h5> <p>上一个函数调用的结果将作为第一个参数传递给下一个函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> value <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">accumulator<span class="token punctuation">,</span> item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>initial<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><ul><li><code>accumulator</code> —— 是上一个函数调用的结果，第一次等于 <code>initial</code>（如果提供了 <code>initial</code> 的话）。</li> <li><code>item</code> —— 当前的数组元素。</li> <li><code>index</code> —— 当前索引。</li> <li><code>arr</code> —— 数组本身。</li></ul> <p>因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 <code>reduce</code> 的结果。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//一行代码得到一个数组的总和</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//accumulator:(sum, current) =&gt; sum + current，initial：0</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">sum<span class="token punctuation">,</span> current</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> sum <span class="token operator">+</span> current<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span>



</code></pre></div><p>如果没有初始值，那么 <code>reduce</code> 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。。如果数组为空，那么在没有初始值的情况下调用 <code>reduce</code> 会导致错误。建议始终指定初始值。</p> <h5 id="arr-reduceright"><a href="#arr-reduceright" class="header-anchor">#</a> arr.reduceRight()</h5> <p>遍历为从右到左</p> <p>array转成字符串</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>arr1<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
arr2<span class="token operator">=</span>arr1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


</code></pre></div><h5 id="arr-sort"><a href="#arr-sort" class="header-anchor">#</a> arr.sort()</h5> <p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener noreferrer">arr.sort<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法对数组进行 <strong>原位（in-place）</strong> 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)</p> <p>它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 <code>arr</code> 本身。</p> <p><code>Array.sort(compareFunction)</code>了，<code>compareFunction</code>接受两个值，假设为<code>a</code>和<code>b</code>，<code>compareFunction(a, b)</code>的返回值有三种情况：</p> <ul><li><code>compareFunction(a, b)</code> &lt; 0，<code>a</code>将会被排到<code>b</code>的前面。</li> <li><code>compareFunction(a, b)</code> = 0，二者相对位置不发生改变。</li> <li><code>compareFunction(a, b)</code> &gt; 0，<code>a</code>将会被排到<code>b</code>的后面。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//直接调用，不指定排序func，会按照字符串形式排序</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>			<span class="token comment">//1,15,2   按照字符串顺序排序了</span>


<span class="token comment">//指定排序func，sort会遍历arr，将arr中的值作为func的参数，</span>
<span class="token comment">//func返回值:为正,a排在b后面，升序；为负,a排在b前面,降序</span>

<span class="token comment">//升序</span>
<span class="token comment">//retun a-b&gt;0   a&gt;b   b a(升序)</span>
<span class="token comment">//return a-b&lt;0   a&lt;b		a b(降序)</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
<span class="token function">alert</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1, 2, 15</span>

<span class="token comment">//降序</span>
<span class="token comment">//return b-a&gt;0   a&lt;b   b a(降序)</span>
<span class="token comment">//return b-a&lt;0   a&gt;b		a b(降序)</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			
<span class="token function">alert</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 15, 2, 1</span>


</code></pre></div><p><strong>乱序</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//使用 Math.random()：

var values = [1, 2, 3, 4, 5];

values.sort(function(){
    return Math.random() - 0.5;
});

console.log(values)
// Math.random() - 0.5 随机得到一个正数、负数或是 0，如果是正数则降序排列，如果是负数则升序排列，如果是 0 就不变，然后不断的升序或者降序，最终得到一个乱序的数组。

</code></pre></div><h4 id="字符串数组方法"><a href="#字符串数组方法" class="header-anchor">#</a> 字符串数组方法</h4> <p>字符串分割、结构</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>location<span class="token operator">=</span><span class="token string">&quot;120.046869,31.633804&quot;</span>
item<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>     <span class="token punctuation">[</span><span class="token number">120.046869</span><span class="token punctuation">,</span><span class="token number">31.633804</span><span class="token punctuation">]</span>		字符串分割
<span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token operator">=</span>item<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>    <span class="token comment">//数组解构</span>


</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//技巧
//删除最后一个字符
const str='str1'
console.log


</code></pre></div><h5 id="逆序"><a href="#逆序" class="header-anchor">#</a> 逆序</h5> <p>使用场景</p> <p>![屏幕快照 2022-03-01 下午5.55.44](../H5C3/图片/屏幕快照 2022-03-01 下午5.55.44.png)</p> <p>使用reverse()</p> <div class="language- extra-class"><pre class="language-text"><code>function reverseString(str) {
	return str.split('').reverse().join('');
}
let str='abcdefg'
console.log(reverseString(str));


</code></pre></div><p>栈方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//数组模拟栈</span>
<span class="token keyword">function</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">//构造函数首字母大写</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>			<span class="token comment">//top指向下一个被push的位置，栈顶的后一个</span>
<span class="token punctuation">}</span>


<span class="token class-name">Stack</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token punctuation">{</span>			<span class="token comment">//在函数的原型链上添加方法</span>
	<span class="token function-variable function">push</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">elem</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>elem<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function-variable function">pop</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token operator">--</span><span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function-variable function">length</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>top
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> s<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> sarr<span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token string">''</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sarr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sarr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sarr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token operator">+=</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res  
<span class="token punctuation">}</span>

<span class="token keyword">let</span> str<span class="token operator">=</span><span class="token string">'abcdefg'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">reverseString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>


</code></pre></div><h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p>由键名：键值组成的集合，键名、键值可以是任何类型</p> <p>map像object，但是map可以存储任何类型的键名key，map可以使用对象键，object不可，因为object会将所有键都转化为字符串键</p> <h4 id="属性和方法"><a href="#属性和方法" class="header-anchor">#</a> 属性和方法</h4> <ul><li><p><code>new Map()</code> —— 创建 map。</p></li> <li><p><code>map.set(key, value)</code> —— 根据键存储值，可以链式调用。</p> <div class="language- extra-class"><pre class="language-text"><code>map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
</code></pre></div></li> <li><p><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</p></li> <li><p><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</p></li> <li><p><code>map.delete(key)</code> —— 删除指定键的值。</p></li> <li><p><code>map.clear()</code> —— 清空 map。</p></li> <li><p><code>map.size</code> —— 返回当前元素个数。</p></li></ul> <h4 id="map-迭代"><a href="#map-迭代" class="header-anchor">#</a> Map 迭代</h4> <p>如果要在 <code>map</code> 里使用循环，可以使用以下三个方法：</p> <ul><li><p><code>mapName.keys()</code> —— 遍历并返回所有的键（returns an iterable for keys），</p></li> <li><p><code>mapName.values()</code> —— 遍历并返回所有的值（returns an iterable for values），</p></li> <li><p><code>mapName.entries()</code> —— 遍历并返回所有的实体（returns an iterable for entries）<code>[key, value]</code>，<code>for..of</code> 在默认情况下使用的就是这个。</p></li> <li><p>mapName.forEach()</p> <div class="language- extra-class"><pre class="language-text"><code>// 对每个键值对 (key, value) 运行 forEach 函数
recipeMap.forEach( (value, key, map) =&gt; {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});

</code></pre></div></li></ul> <h3 id="set"><a href="#set" class="header-anchor">#</a> set</h3> <p>只有键值的集合，值不重复，可以是任何类型，如对象类型</p> <div class="language- extra-class"><pre class="language-text"><code>let set=new set();

let john = { name: &quot;John&quot; };
let pete = { name: &quot;Pete&quot; };
let mary = { name: &quot;Mary&quot; };

set.add(john);
set.delete(john);
set.has(john)
set.clear()
set.size

set.keys() —— 遍历并返回所有的值（returns an iterable object for values），
set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map，
set.entries() —— 遍历并返回所有的实体（returns an iterable object for entries）[value, value]，它的存在也是为了兼容 Map。
</code></pre></div><p>####输出元素类型</p> <div class="language- extra-class"><pre class="language-text"><code>console(typeof  &quot;string&quot;);				//string 

console(typeof  123);				//number

console(typeof (&quot;string&quot;));			//string
</code></pre></div><p>###数据类型转换</p> <div class="language- extra-class"><pre class="language-text"><code>var message1=&quot;123&quot;;		//message为string

var num1=Number(message1);					//num为number



var message2=&quot;abc&quot;;

var num2=Number(message2);				//NaN:not a number(NaN是number类型)



console.log(Number(true));			//1

console.log(Number(false));			//0



console.log(Number(undefined));			//NaN



consolr.log(Number(null));				//0
</code></pre></div><h2 id="数字类型"><a href="#数字类型" class="header-anchor">#</a> 数字类型</h2> <h4 id="parseint-parsefloat"><a href="#parseint-parsefloat" class="header-anchor">#</a> parseInt()/parseFloat()</h4> <p>从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 <code>parseInt</code> 返回一个整数，而 <code>parseFloat</code> 返回一个浮点数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'100px'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'12.5em'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12.5</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'12.3'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12，只有整数部分被返回了</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">'12.3.4'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12.3，在第二个点出停止了读取</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'a123'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN，第一个符号停止了读取</span>

</code></pre></div><p><code>parseInt()</code> 函数具有可选的第二个参数。它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 255</span>
<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'ff'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 255，没有 0x 仍然有效</span>

<span class="token function">alert</span><span class="token punctuation">(</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2n9c'</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123456</span>
</code></pre></div><p>toFixed()</p> <p>函数 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed" target="_blank" rel="noopener noreferrer">toFixed(n)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 将数字舍入到小数点后 <code>n</code> 位，并以字符串形式返回结果。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">12.34</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;12.3&quot;</span>
</code></pre></div><p>这会向上或向下舍入到最接近的值，类似于 <code>Math.round</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">12.36</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;12.4&quot;</span>
</code></pre></div><p><code>toFixed</code> 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">12.34</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span> num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后五位</span>
</code></pre></div><h1 id="object对象"><a href="#object对象" class="header-anchor">#</a> object对象</h1> <p>对象：一组没有特定顺序的值，由键名key和键值value组成</p> <p>对象的属性或方法由一个名称标识，值可以是数据或者函数</p> <h2 id="基本创建方法"><a href="#基本创建方法" class="header-anchor">#</a> 基本创建方法</h2> <p><strong>new</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let person=new Object();
person.name='pname'
person.sayName=()=&gt;{
	console.log(this.name)
}
</code></pre></div><p><strong>对象字面量</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let person= {
	name:'pname',
	sayName() {
		console.log(this.name)
	}
}
</code></pre></div><h2 id="对象属性"><a href="#对象属性" class="header-anchor">#</a> 对象属性</h2> <p><strong>属性访问方法</strong></p> <p>.操作符</p> <div class="language- extra-class"><pre class="language-text"><code>objectName.propertyName

</code></pre></div><p>[]操作符</p> <div class="language- extra-class"><pre class="language-text"><code>objectName[&quot;propertyName&quot;]

</code></pre></div><p>区别</p> <p>[] 操作符是动态的，可以传变量、数字、字符串</p> <p>.操作符是静态的，必须是有效变量名形式</p> <div class="language- extra-class"><pre class="language-text"><code>let name=&quot;person name&quot;

person[name]		
person.name    //error

person[&quot;person name&quot;]
person.person name 		//error

person[1]
person.1			//error

</code></pre></div><h2 id="对象属性特征描述"><a href="#对象属性特征描述" class="header-anchor">#</a> 对象属性特征描述</h2> <p>用来配置对象的每个属性</p> <p>每个对象属性的数据属性，描述这个属性是否可删、可改、可迭代、值配置</p> <p>每个对象属性的访问器属性，包含一个获取(getter)函数和一个设置(setter)函数</p> <h3 id="数据属性"><a href="#数据属性" class="header-anchor">#</a> 数据属性</h3> <p><strong>4个特性</strong></p> <p>数据属性有4个特性描述它们的行为。</p> <p>前三个默认为true</p> <p>[[Configurable]]</p> <p>表示属性是否可以通过delete删除并重新定义,是否可以修改它的特性，以及是否可以把它改为访问器属性。</p> <p>默认为true，通过defineProperty改为false之后，非严格模式下无法删除对象属性，严格模式下error，</p> <p>设置为false后，不可再修改了</p> <p>[[Enumerable]]</p> <p>表示属性是否可以通过for-in循环返回。</p> <p>[[writable]]</p> <p>表示属性的值是否可以被修改</p> <p>默认为true，通过defineProperty改为false之后，非严格模式下无法删除对象属性，严格模式下error</p> <p>[[Value]]</p> <p>包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为
undefined。</p> <p><strong>修改特性</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Object.defineProperty(修改对象名,对象属性名,配置项)

</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'pname'</span>
<span class="token punctuation">}</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
	<span class="token literal-property property">value</span><span class="token operator">:</span><span class="token string">&quot;pname1&quot;</span><span class="token punctuation">,</span>		<span class="token comment">//修改值</span>
	<span class="token literal-property property">writable</span><span class="token operator">:</span><span class="token boolean">false</span>				<span class="token comment">//不能再修改了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

person<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">&quot;pname2&quot;</span>		<span class="token comment">//非严格忽略，严格error</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>			<span class="token comment">//pname1</span>

</code></pre></div><h3 id="访问器属性"><a href="#访问器属性" class="header-anchor">#</a> 访问器属性</h3> <p>访问器属性不包含数据值,包含一个获取(getter) 函数和一个设置(setter) 函数，</p> <p>在读取访问器属性时，会调用获取函数,这个函数的责任就是返回一个有效的值。</p> <p>在写入访问器属性时,会调用设置函数并传入新值,这个函数必须决定对数据做出什么修改。</p> <p>访问器属性有4个特性描述它们的行为。</p> <p>[[Configurable]]:表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把
它改为数据属性。默认情况下，所有直接定义在对象.上的属性的这个特性都是true。</p> <p>[[Enumerable]]：表示属性是否可以通过for-in循环返回。默认情况下，所有直接定义在对象上的属性的这个</p> <p>特性都是true。</p> <p>[[Get]]:获取函数,在读取属性时调用。默认值为undefined.</p> <p>[[Set]]: 设置函数,在写入属性时调用。默认值为undefined。</p> <p>访问器属性是不能直接定义的，必须使用Object.defineProperty()。</p> <div class="language- extra-class"><pre class="language-text"><code>let book = {
	year_:2017,			//属性名_  表示私有成员，不希望该属性在对象方法的外部使用
	edition:1				//普通成员
}
//define对象的year属性，无论year在不在book中都可以define,创建普通属性来操作私有属性
Object.defineProperty(book,&quot;year&quot;,{
	get:function () {
		return this.year_
	},
	set:function (newValue) {
		if(newValue&gt;2017) {
			this.year_=newValue;
			this.edition+=newValue-2017
		}
	}
})
book.year=2019		//调用了set方法,year_=year=2019
console.log(book.edition)   //2

</code></pre></div><h4 id="对象方法"><a href="#对象方法" class="header-anchor">#</a> 对象方法</h4> <h5 id="object-entries-obj"><a href="#object-entries-obj" class="header-anchor">#</a> Object.entries(obj)</h5> <p><code>Object.entries()</code>返回一个数组，其元素是与直接在<code>object</code>上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//Object.entries(obj)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token literal-property property">baz</span><span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ ['foo', 'bar'], ['baz', 42] ]</span>

<span class="token comment">// array like object</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]</span>

<span class="token comment">// 对象转map</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">baz</span><span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Map { foo: &quot;bar&quot;, baz: 42 }</span>

</code></pre></div><h2 id="设计模式创建对象"><a href="#设计模式创建对象" class="header-anchor">#</a> 设计模式创建对象</h2> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> <strong>工厂模式</strong></h3> <p>抽象出创建对象和属性赋值的过程，根据传入的属性值批量创建对象，减少冗余重复的属性编写</p> <div class="language- extra-class"><pre class="language-text"><code>function createPerson(name,age,address) {
	let o=new Object();
	o.name=name;
	o.age=age;
	o.getName=function() {
		return this.name;
	}
	return o;
}

let person1=createPerson('person1Name',18,{
	name:'address name1',
	code:'100000'
})
console.log(person1)
let person2=createPerson('person2Name',18,{
	name:'address name2',
	code:'100000'
})
console.log(person2)

</code></pre></div><p>缺点：创建的实例都是绑定在O上的，不能更好的区分</p> <h4 id="基于构造函数创建对象"><a href="#基于构造函数创建对象" class="header-anchor">#</a> 基于构造函数创建对象</h4> <div class="language- extra-class"><pre class="language-text"><code>function Person(name,age) {
	this.name=name;
	this.age=age;
	this.getName=function() {
		return this.name
	}
	return o;
}
let person1=Person('person1Name',18,{
	name:'address1',
	code:'code1'
})
console.log(person1)		

let person2=Person('person2Name',18,{
	name:'address2',
	code:'code2'
})
console.log(person2)	
</code></pre></div><p>缺点：每个实例的函数都会占据一定的空间，资源浪费</p> <h4 id="基于构造函数和原型混合创建对象"><a href="#基于构造函数和原型混合创建对象" class="header-anchor">#</a> 基于构造函数和原型混合创建对象</h4> <p>构造函数与 通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个 函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操 作符调用的函数就是 通函数。</p> <p>使用构造函数定义实例对象属性，使用原型对象定义实例对象的共享属性和函数方法，使得属性都有自己的属性值，同时共享函数引用，节省内存空间</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(name,age) {
	this.name=name;
	this.age=age;
	this.address=address;
}
Person.prototype.getName=function() {
	return this.name;
}

let person1=new Person('person1',18)
let person2=new Person('person2',18)

console.log(person1.getName())		//person1
console.log(person2.getName())		//person2
console.log(person1.getName===person2.getName)		//true，共享了getName()
person2.name='person22'			//改变实例属性，不影响其他实例的属性值
console.log(person1.getName())		//person1				
console.log(person2.getName())		//person22
</code></pre></div><p>缺点：每次在创建实例的时候，都会进行原型设置</p> <h3 id="基于动态原型创建对象"><a href="#基于动态原型创建对象" class="header-anchor">#</a> 基于动态原型创建对象</h3> <p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例 共享的属性和方法。</p> <p>使用原型对象的好处 是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以 直接赋值给它们的原型，</p> <h2 id="原型、原型链"><a href="#原型、原型链" class="header-anchor">#</a> 原型、原型链</h2> <p>构造函数都有一个原型对象prototype，这个原型对象又有constructor属性指回构造函数，构造函数创建的实例有一个指针<code>_proto_</code>指向原型对象</p> <p>如果原型是另一个类型的实例，那么这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函 数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p> <img src="https://camo.githubusercontent.com/9a69b0f03116884e80cf566f8542cf014a4dd043fce6ce030d615040461f4e5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67" alt="原型链示意图" style="zoom:50%;"> <h1 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h1> <p>在 JavaScript 中，函数是对象类型。可被调用的“行为对象（action object）”。我们不仅可以调用它们，还能把它们当作对象来处理：增/删属性，按引用传递等。</p> <p>函数名是保存指针的变量</p> <p>console.log(func)</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(func)			//打印函数
func()			//执行函数
</code></pre></div><h2 id="创建函数"><a href="#创建函数" class="header-anchor">#</a> 创建函数</h2> <div class="language- extra-class"><pre class="language-text"><code>函数声明法
function func() {

}
函数表达式
let func=function () {

}

function func() {
	...
	return function () {
	
	}
}
</code></pre></div><p>函数属性</p> <p>一个内建属性 “length”，它返回函数入参的个数</p> <div class="language- extra-class"><pre class="language-text"><code>functionName.length
</code></pre></div><h2 id="this指向"><a href="#this指向" class="header-anchor">#</a> this指向</h2> <p><strong>标准函数中，this指向函数／方法的调用者</strong></p> <p>创建构造函数实例时，需要new出这个实例，此时this就指向这个实例</p> <p>普通函数执行，不new实例，this指向全局window</p> <p>在对象方法内，对象调用了方法，方法的this指向该对象</p> <p>匿名函数中的this指向window</p> <p><strong>箭头函数中,this指向 定义箭头函数的上下文（箭头函数在哪个上下文里定义的就指向哪里）</strong></p> <p>使用对象方法call() apply() bind()可以改变this指向</p> <p>基于Function.prototype上的 <code>apply 、 call 和 bind</code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code> this <code>绑定了传入对象的新函数。这个函数的</code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</p> <h3 id="具体例子"><a href="#具体例子" class="header-anchor">#</a> 具体例子</h3> <p>创建构造函数实例时，需要new出这个实例，此时this就指向这个实例</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(name) {			//构造函数函数名大写
	this.name=name;
}
var p=new Person('person_name');		//p为实例
console.log(p.name)			//this指向p

</code></pre></div><p>普通函数执行，不new实例，this指向全局window</p> <div class="language- extra-class"><pre class="language-text"><code>function person() {
	this.name=name
}
person('person_name')
console.log(window.name)


</code></pre></div><p>在对象方法内，对象调用了方法，方法的this指向该对象</p> <div class="language- extra-class"><pre class="language-text"><code>var value=10;
var obj={
	value:100,
	get:()=&gt;{
		console.log(this.value);
	}
}
obj.get();			//100


</code></pre></div><p>匿名函数中的this指向window</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>			<span class="token comment">//window</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> user<span class="token operator">=</span><span class="token punctuation">{</span>
	<span class="token literal-property property">sport</span><span class="token operator">:</span><span class="token string">'user_sport'</span><span class="token punctuation">,</span>
	<span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">[</span>
		<span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'userName1'</span><span class="token punctuation">,</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'userName2'</span><span class="token punctuation">,</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span>
	<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">clickHander</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//user对象调用clickHander,this指向user</span>
    <span class="token keyword">var</span> _this<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>			<span class="token comment">//保存</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>			<span class="token comment">//window</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'is playing'</span><span class="token operator">+</span> _this<span class="token punctuation">.</span>sport<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
user<span class="token punctuation">.</span><span class="token function">clickHander</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><p><strong>箭头函数中,this指向 定义箭头函数的上下文（箭头函数在哪个上下文里定义的就指向哪里）</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">'aa'</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">//aa，箭头函数内this指向箭头函数的定义上下文</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">'bb'</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>		<span class="token comment">//undefined,普通函数内this指向调用者，b是window调用的，window对象中没有name所以undefined</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="函数方法"><a href="#函数方法" class="header-anchor">#</a> 函数方法</h2> <h3 id="call-apply-bind"><a href="#call-apply-bind" class="header-anchor">#</a> call() apply() bind()</h3> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>引用了另一个函数作用域的变量的函数，通常在嵌套函数中实现</p> <p>函数有函数作用域，外部函数无法访问内部函数的变量，内部函数可以访问外部。</p> <p>那么将内部函数return出去，就可以实现在别的作用域中访问</p> <p><strong>闭包形成的条件</strong>：</p> <ol><li>函数的嵌套</li> <li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol> <p><strong>闭包的特性</strong>：</p> <ul><li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p> <p>1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的</p> <p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p></li> <li><p>2、函数嵌套函数</p></li> <li><p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p></li></ul> <p><strong>闭包的用途</strong>：</p> <ol><li>模仿块级作用域</li> <li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li> <li>封装私有化变量</li> <li>创建模块</li></ol> <p><strong>闭包应用场景</strong>：回调函数</p> <p>一个事件绑定的回调方法;</p> <p>发送ajax请求成功|失败的回调;</p> <p>setTimeout的延时回调;</p> <p>或者一个函数内部返回另一个匿名函数</p> <p><strong>闭包的优点</strong>：延长局部变量的生命周期</p> <p><strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p> <h2 id="回调函数callback"><a href="#回调函数callback" class="header-anchor">#</a> 回调函数callback</h2> <p>某个操作执行结束后，自动被调用的函数</p> <p>例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//callback：隐藏后回调函数，显示弹窗</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token string">'slow'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'...hided...'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//不写成callback，先弹窗，再隐藏</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'...hided...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="闭包-2"><a href="#闭包-2" class="header-anchor">#</a> 闭包</h4> <p>函数嵌套：在一个函数内部定义函数</p> <p>闭包：内部函数可以访问其所在外部函数的变量和参数，即使外部函数return了</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//闭包实现sum(a)(b)=a+b</span>
<span class="token comment">//sum(1)(2)=3</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//写法1</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//写法2</span>
  <span class="token keyword">return</span> <span class="token parameter">b</span><span class="token operator">=&gt;</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

</code></pre></div><h5 id="settimeout"><a href="#settimeout" class="header-anchor">#</a> setTimeOut()</h5> <p>将函数推迟到一段时间间隔之后再执行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>func<span class="token operator">|</span>code<span class="token punctuation">,</span> <span class="token punctuation">[</span>delay<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>


</code></pre></div><p>参数说明：</p> <ul><li><p><code>func|code</code></p> <p>想要执行的函数或代码字符串。 一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。</p></li> <li><p><code>delay</code></p> <p>执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；</p></li> <li><p><code>arg1</code>，<code>arg2</code>…</p> <p>要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p></li></ul> <h5 id="cleartimeout"><a href="#cleartimeout" class="header-anchor">#</a> clearTimeOut()</h5> <p>取消调度</p> <h4 id="function-立即调用函数表达式"><a href="#function-立即调用函数表达式" class="header-anchor">#</a> (function(){})();立即调用函数表达式</h4> <p>在之前，JavaScript 中只有 <code>var</code> 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，程序员们就发明了一种模仿块级作用域的方法。这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）。</p> <p>需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用。</p> <h3 id="call-apply"><a href="#call-apply" class="header-anchor">#</a> call()  apply()</h3> <p>通过call(),apply可以改变函数执行主体，使得执行主体(对象)可以直接调用该函数</p> <div class="language- extra-class"><pre class="language-text"><code>function sum(num1,num2) {
	return num1+num2
}

var Person={}
console.log(sum.call(Person,1,2))
console.log(sum.call(Person,[1,2]))

</code></pre></div><h4 id="改变指向-call-apply-bind"><a href="#改变指向-call-apply-bind" class="header-anchor">#</a> 改变指向 call() apply() bind()</h4> <div class="language- extra-class"><pre class="language-text"><code>var value=10;
var obj={
	value=20;
}

var method=function() {
	console.log(this.value)
}

method();			//10

</code></pre></div><h1 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h1> <h3 id="插入标签"><a href="#插入标签" class="header-anchor">#</a> 插入标签</h3> <p>示例html代码：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>color:red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>test1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> test2
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>


</code></pre></div><p>获得id为test的DOM对象，下面就不一一获取了。</p> <div class="language-dart extra-class"><pre class="language-dart"><code><span class="token keyword">var</span> test <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">'test'</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><h4 id="innerhtml"><a href="#innerhtml" class="header-anchor">#</a> innerHTML</h4> <p>描述：也就是从对象的起始位置到终止位置的全部内容,包括Html标签。</p> <p>上例中的test.innerHTML的值也就是<code>“test1 test2 ”。</code></p> <h4 id="innertext"><a href="#innertext" class="header-anchor">#</a> innerText</h4> <p>描述：从起始位置到终止位置的内容, 但它去除Html标签 。</p> <p>上例中的test.innerText的值也就是<code>“test1 test2”</code>, 其中<code>span</code>标签去除了。</p> <h4 id="outerhtml"><a href="#outerhtml" class="header-anchor">#</a> outerHTML</h4> <p>描述：除了包含innerHTML的全部内容外, 还包含对象标签本身。</p> <p>上例中的test.outerHTML的值也就是<code>test1 test2</code></p> <p>完整示例：</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>color:red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>test1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> test2
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>javascript:alert(test.innerHTML)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>innerHTML内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>javascript:alert(test.innerText)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>inerText内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>javascript:alert(test.outerHTML)<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>outerHTML内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>


</code></pre></div><p>结果：</p> <div class="language-awk extra-class"><pre class="language-text"><code>//test.innerHTML结果：&lt;span style=&quot;color:red&quot;&gt;test1&lt;/span&gt; test2
//test.innerText结果:test1 test2
//test.outerHTML结果：&lt;div id=&quot;test&quot;&gt;&lt;span style=&quot;color:red&quot;&gt;test1&lt;/span&gt; test2&lt;/div&gt;


</code></pre></div><h4 id="textcontent"><a href="#textcontent" class="header-anchor">#</a> textContent</h4> <p>描述：textContent 属性设置或返回指定节点的文本内容，以及它的所有后代。</p> <p>提示：有时，此属性可用于取代 nodeValue 属性，但是请记住此属性同时会返回所有子节点的文本。</p> <p>得到的结果跟innerText的结果是一样的。</p> <blockquote><p>注释：Internet Explorer 8 以及更早的版本不支持此属性。</p></blockquote> <h4 id="兼容性"><a href="#兼容性" class="header-anchor">#</a> 兼容性</h4> <p><code>innerHTML</code>所有浏览器兼容；<code>innerText</code>与<code>outerHTML</code>虽然主流浏览器，如谷歌，火狐，IE7-IE11，QQ等都已支持（这里提到的谷歌火狐等都是最新浏览器的版本），但是<code>W3C</code>的标准属性就是<code>innerHTML</code>,因此，尽可能地去使用<code>innerHTML</code>，而少用<code>innerText</code>与<code>outerHTML</code>。</p> <h4 id="insertadjacenthtml-位置-html"><a href="#insertadjacenthtml-位置-html" class="header-anchor">#</a> insertAdjacentHTML(位置,HTML)</h4> <h4 id="insertadjacenttext-位置-text"><a href="#insertadjacenttext-位置-text" class="header-anchor">#</a> insertAdjacentText(位置,Text)</h4> <p>&quot;beforebegin&quot; :  插入到当前元素前面，作为前一个同胞节点</p> <p>afterbegin:插入到当前元素内部，作为新的子节点或放在第一个子节点前面</p> <p>beforeend:插入到当前元素内部，作为新的子节点或放在最后一个子节点前面</p> <p>afterend:插入到当前元素后面，作为下一个同胞节点</p> <h2 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h2> <h3 id="事件对象"><a href="#事件对象" class="header-anchor">#</a> 事件对象</h3> <h4 id="dom事件对象"><a href="#dom事件对象" class="header-anchor">#</a> DOM事件对象</h4> <p>事件处理程序的唯一参数event</p> <p>event对象的属性／方法</p> <table><thead><tr><th>stopPropagation()</th> <th>取消后续事件捕获或冒泡，当bubbles为true时可以调用</th></tr></thead> <tbody><tr><td></td> <td></td></tr> <tr><td></td> <td></td></tr> <tr><td></td> <td></td></tr></tbody></table> <h3 id="事件流"><a href="#事件流" class="header-anchor">#</a> 事件流</h3> <p><a href="http://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener noreferrer">DOM 事件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>标准描述了事件传播的 3 个阶段：</p> <ol><li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li> <li>目标阶段（Target phase）—— 事件到达目标元素。</li> <li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li></ol> <p>事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序。</p> <p>页面上table表格，click某个表格单元td</p> <p>捕获型事件流：table—tbody—tr—td  向内传播</p> <p>冒泡事件流：td—tr—tbody—table 向外传播</p> <p>一个事件流包含三个阶段</p> <p>捕获—目标—冒泡</p> <h3 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h3> <h3 id="event对象"><a href="#event对象" class="header-anchor">#</a> Event对象</h3> <p>事件以event对象存在，每触发一个事件都会产生一个event对象</p> <p>event对象在不同浏览器实现有差异</p> <p><strong>获取event对象</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1、作为事件处理程序的参数传入获取
2、window.event获取


</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let btn=document.getElementById(&quot;button&quot;);
btn.addEventListener('click',(event)=&gt;{
	//方法1:作为事件处理程序的参数传入
	console.log(event);
	//方法2:通过windwo.event获取
	let windowEvent=window.event;
	console.log(windowEvent)
	//判断是否一致
	console.log(windowEvent===event)
})


</code></pre></div><p><strong>获取event对象的目标元素</strong></p> <div class="language- extra-class"><pre class="language-text"><code>e.srcElement
e.target


</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//先定义事件获取对象
let EventUtil={
	getEvent:function(event) {
		return event||window.event
	}
}
//再获取目标元素
let btn=document.getElementById(&quot;button&quot;);
btn.addEventListener(&quot;click&quot;,function(event) {
	//获取对象，如果传参形式获取到了，那么event===event，否则event===window.event
	let event=EventUtil.getEvent(event);
	//两种方式获取目标元素  event.srcElement 和 event.target
	let NoIETarget=event.target		//chrome safari
	let IETarget=event.srcElement
})


</code></pre></div><p>不同浏览器支持获取方式不同</p> <div class="language- extra-class"><pre class="language-text"><code>//适配不同浏览器，定义事件获取对象
let EventUtil={
	getEvent:function(event) {
		return event || window.event
	}
	getTarget:function(event) {
		return e.target||e.srcElement
	}
}


</code></pre></div><h3 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h3> <p>JS是单线程的，</p> <p>为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列。</p> <p>异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。</p> <p>微任务队列的代表就是，<code>Promise.then</code>，<code>MutationObserver</code>，宏任务的话就是`setImmediate setTimeout setInterval</p> <h2 id="拖动事件"><a href="#拖动事件" class="header-anchor">#</a> 拖动事件</h2> <p>默认情况下，图片、链接和文本是可拖动的，这意味着无须额外代码用户便可以拖动它们。文本只
有在被选中后才可以拖动，而图片和链接在任意时候都是可以拖动的。
我们也可以让其他元素变得可以拖动。HTML5在所有HTML元素上规定了-一个draggable属性，
表示元素是否可以拖动。图片和链接的draggable属性自动被设置为true,而其他所有元素此属性的默认值为false。如果想让其他元素可拖动，或者不允许图片和链接被拖动，都可以设置这个属性。</p> <p>某元素被拖动，会按顺序触发以下事件</p> <p>dragstart:开始拖动那一刻触发，目标元素this为被拖动元素</p> <p>drag：拖住不放持续触发</p> <p>dragenter:拖动到某个有效放置触发，this为有效位置元素</p> <p>dragover:触发完dragenter后立即触发dragover，并且持续出发直到离开当前有效放置范围，this为有效位置元素</p> <p>dragleave:触发完dragover后触发dragleave，this为有效位置元素</p> <p>drop:放到了目标位置触发</p> <p>dragend：拖动到目标位置释放元素时触发</p> <h1 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h1> <p>栈 堆</p> <p>基本数据类型number、str、boolean存在栈上</p> <h3 id="var-let-const"><a href="#var-let-const" class="header-anchor">#</a> var\let\const</h3> <p>var:没有块级作用域</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//var会变量提升</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//变量提升，返回undefined</span>
<span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">//var可以重复定义</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span>
<span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//20</span>

<span class="token comment">//var没有块级作用域，es5只有全局和函数作用域，var在大括号之后还可以访问</span>
<span class="token punctuation">{</span>
  <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//var声明for循环的变量，循环外还可以输出，循环结束输出无意义</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//9</span>

</code></pre></div><p>let：更完美的var, 没有直接废弃var是考虑到兼容性问题，考虑到执行效率</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//let取消预解析，变量声明不会提升，必须在声明后使用</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//报错</span>
<span class="token keyword">let</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">//let不可以重复定义</span>
<span class="token keyword">let</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">//error</span>


<span class="token comment">//let存在块级作用域，es6存在块级作用域</span>
<span class="token punctuation">{</span>
	<span class="token keyword">let</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//error</span>

<span class="token comment">//let声明的for循环变量，for作用域外访问不到，error:not declared</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//error:i not declared</span>

</code></pre></div><p>const声明</p> <p>const声明一个常量，代码中有数据在执行过程中不变化，声明为常量</p> <p>在声明时必须初始化，</p> <p>不能重新赋值，</p> <p>不能重复声明</p> <p>基本值类型数据不可以修改，引用类型的值可以修改，因为const是对引用地址修改的限制，只要不改变内存地址，可以改该内存地址上的值</p> <div class="language- extra-class"><pre class="language-text"><code>const age=26
age=36			//error

const arr=[10,10,12]
arr[1]=11			// [10,11,12]，ok
</code></pre></div><h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>let c=a=&gt;b</p> <p>用a执行b，返回给c</p> <p>a=&gt;b</p> <p>a：只有一个参数,可以省略括号；没有参数／多个不可省略；</p> <p>b：一行可省{}，多行不可；都别省！</p> <p>回调callback函数</p> <p>在某些行为action完成后调用的函数</p> <p>异步执行某项功能的函数应该提供一个 <code>callback</code> 参数用于在相应事件完成时调用。</p> <h3 id="spread语法"><a href="#spread语法" class="header-anchor">#</a> spread语法</h3> <p>展开可迭代对象</p> <div class="language- extra-class"><pre class="language-text"><code>let arr = [3, 5, 1];
//...arr    将可迭代对象arr展开成3,5,1
alert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）


let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];   // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）

//使用 spread 语法将字符串转换为字符数组
let str = &quot;Hello&quot;;
alert( [...str] ); // H,e,l,l,o
//使用 Array.from 来实现将字符串转换为字符数组
alert( Array.from(str) ); // H,e,l,l,o
//两种方法区别：Array.from 适用于类数组对象也适用于可迭代对象，Spread 语法只适用于可迭代对象。



</code></pre></div><p>Map</p> <div class="language- extra-class"><pre class="language-text"><code>let level1Map=new Map()
temp.forEach((item,index)=&gt;{
level1Map.set(item.deps_id,index)
})
for (let entry of level1Map) { // 与 recipeMap.entries() 相同
console.log(entry); // cucumber,500 (and so on)
}


</code></pre></div><h3 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//executor执行函数</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>


</code></pre></div><p>传递给 <code>new Promise</code> 的函数被称为 <strong>executor</strong>。</p> <p>当 <code>new Promise</code> 被创建，executor 会自动运行并尝试执行一项工作。</p> <p>尝试结束后，如果成功则调用 <code>resolve</code>，如果出现 error 则调用 <code>reject</code>。</p> <p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p> <p>![屏幕快照 2021-09-05 上午10.17.06](../H5C3/图片/屏幕快照 2021-09-05 上午10.17.06.png)</p> <p><strong>executor 只能调用一个 <code>resolve</code> 或一个 <code>reject</code>。</strong></p> <p>任何状态的更改都是最终的。所有其他的再对 <code>resolve</code> 和 <code>reject</code> 的调用都会被忽略：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;…&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 被忽略</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;…&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 被忽略</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><p><strong>Resolve/reject 可以立即进行</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let promise = new Promise(function(resolve, reject) {
  // 不花时间去做这项工作
  resolve(123); // 立即给出结果：123
});


</code></pre></div><h4 id="promise封装"><a href="#promise封装" class="header-anchor">#</a> promise封装</h4> <p>封装settimeout</p> <div class="language- extra-class"><pre class="language-text"><code>function delay(ms) {
	return new Promise(resolve=&gt;setTimeput(resolve,ms))
}
delay(3000).then(()=&gt;{
	alert('after 3000ms');
	return delay(2000);
	}).then(value=&gt;{
	....
	})
</code></pre></div><p><strong>访问state和result</strong></p> <p>Promise 对象的 <code>state</code> 和 <code>result</code> 属性都是内部的。我们无法直接访问它们。使用 <code>.then</code>/<code>.catch</code>/<code>.finally</code> 方法。</p> <p>then</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">/* handle a successful result */</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">/* handle an error */</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><p><code>.then</code> 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收结果。</p> <p><code>.then</code> 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error。</p> <p>catch</p> <p>只对 error 感兴趣，那么我们可以使用 <code>null</code> 作为第一个参数：<code>.then(null, errorHandlingFunction)</code>。或者我们也可以使用 <code>.catch(errorHandlingFunction)</code>，<code>.catch(f)</code> 调用是 <code>.then(null, f)</code> 的完全的模拟，它只是一个简写形式。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Whoops!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// .catch(f) 与 promise.then(null, f) 一样</span>
promise<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 秒后显示 &quot;Error: Whoops!&quot;</span>

</code></pre></div><h1 id="异步编程"><a href="#异步编程" class="header-anchor">#</a> 异步编程</h1> <h2 id="同步、异步"><a href="#同步、异步" class="header-anchor">#</a> 同步、异步</h2> <p>同步：</p> <p>上一个任务结束后下一个任务才执行，如果一个上一个任务执行需要很长时间，就会阻塞下一个人</p> <p>异步：</p> <p>一个任务分成两段，先执行第一段，然后转而执行下一个任务，等做好了准备，再回过头执行第二段。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，<strong>异步任务不具有”堵塞“效应</strong>。</p> <p>高阶函数</p> <p>函数的一个参数是函数，函数的返回值也是函数</p> <h3 id="柯里化-currying"><a href="#柯里化-currying" class="header-anchor">#</a> 柯里化（Currying）???</h3> <p>是一个辅助函数，这个辅助函数实现对函数的转换</p> <p>将 <code>f(a,b,c)</code> 转换为可以被以 <code>f(a)(b)(c)</code> 的形式进行调用。</p> <p>参数可以传一个或多个，柯里化的原函数都可以正常调用，并且如果</p> <p>参数数量不足，则返回原函数的偏函数／部分函数。</p> <div class="language- extra-class"><pre class="language-text"><code>function sum(a,b,c,d) {
	return a+b+c+d
}

function curring(fn) {
	let args=[]
	const inner=(arr=[])=&gt;{
		args.push(...arr)
		return args.length
	}
}
</code></pre></div><h2 id="异步编程-2"><a href="#异步编程-2" class="header-anchor">#</a> 异步编程</h2> <h3 id="单线程"><a href="#单线程" class="header-anchor">#</a> 单线程</h3> <p>所谓&quot;单线程&quot;，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p> <p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p> <h3 id="同步与异步"><a href="#同步与异步" class="header-anchor">#</a> 同步与异步</h3> <p>&quot;同步模式&quot;就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</p> <p>&quot;异步模式&quot;则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p> <p>&quot;异步模式&quot;非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，&quot;异步模式&quot;甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</p> <h3 id="如何进行异步编程"><a href="#如何进行异步编程" class="header-anchor">#</a> 如何进行异步编程</h3> <p>F1:回调函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//实现点击——隐藏——提示隐藏了——其他事件</span>


<span class="token comment">//callback：隐藏后回调函数，显示弹窗</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>					<span class="token comment">//f1:点击</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token string">'slow'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">//f2:隐藏</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'...hided...'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//不写成callback，先弹窗，再隐藏</span>
<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;p&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'...hided...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>F2:事件监听</p> <p>F3:发布订阅</p> <p>F4:promise</p> <h1 id="模块化moudule"><a href="#模块化moudule" class="header-anchor">#</a> 模块化moudule</h1> <p>模块内</p> <p>写法1：单独export</p> <div class="language- extra-class"><pre class="language-text"><code>//export文件
export const name='name1'
export function sayName() {
	return 'name:'+name;
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>//import文件
&lt;script&gt;
	import {name,sayName} from '相对路径'
&lt;/script&gt;
</code></pre></div><p>写法2：统一export</p> <div class="language- extra-class"><pre class="language-text"><code>const name='name'
function sayName() {
	return 'name:'+name;
}

export {name,sayName}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import {name,sayName} from '相对路径'
</code></pre></div><p>默认export deafult ，import的时候可以自定义名字，export模块内只能写一次</p> <div class="language- extra-class"><pre class="language-text"><code>const name='name'
function sayName() {
	return 'name:'+name;
}

export {name,sayName}

const obj={
	...
}
export default obj
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import objName,{name,sayName} from '...'
</code></pre></div><p>全部import,引入export模块内所有</p> <div class="language- extra-class"><pre class="language-text"><code>import * as f from '...'
</code></pre></div><p>类模块化</p> <div class="language- extra-class"><pre class="language-text"><code>class Person {
	constructor() {
	
	}
	sayName() {
		...
	}
}
export default Person;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>import Person from '相对路径'
</code></pre></div><h1 id="api"><a href="#api" class="header-anchor">#</a> api</h1> <h3 id="math"><a href="#math" class="header-anchor">#</a> Math</h3> <p>Math.ceil()向大取整</p> <p>Math.floor()向小取整</p> <p>Math.round四舍五入</p> <h1 id="bom"><a href="#bom" class="header-anchor">#</a> BOM</h1> <h4 id="回流-重排-重绘"><a href="#回流-重排-重绘" class="header-anchor">#</a> 回流／重排 &amp; 重绘</h4> <p>浏览器使用流式布局模型 (Flow Based Layout)。</p> <p>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</p> <p>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</p> <p><strong>回流必将引起重绘，重绘不一定会引起回流</strong></p> <p><strong>重排</strong></p> <p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流／重排。</p> <p>会导致回流的操作：</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li> <li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li> <li>查询某些属性或调用某些方法</li></ul> <p>一些常用且会导致回流的属性和方法：</p> <ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li> <li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li> <li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li> <li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul> <p><strong>重绘</strong></p> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <p><strong>如何避免</strong></p> <p>CSS</p> <ul><li>避免使用<code>table</code>布局。</li> <li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li> <li>避免设置多层内联样式。</li> <li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li> <li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul> <p>JavaScript</p> <ul><li><p>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</p> <div class="language- extra-class"><pre class="language-text"><code>let ad=document.getElementById(&quot;ad&quot;);
//不要单独写
ad.style.width=&quot;100px&quot;;
ad.style.height=&quot;100px&quot;;
ad.style.background=&quot;100px&quot;;
...

//直接写一个类
div .ad {
	width:100px;
	height:100px;
	background:red;
}
</code></pre></div></li> <li><p>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</p></li> <li><p>需要复杂处理的元素，先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</p></li> <li><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。操作缓存起来的变量，避免频繁读取</p></li> <li><p>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p></li></ul> <h1 id="防抖节流"><a href="#防抖节流" class="header-anchor">#</a> 防抖节流</h1> <h1 id="ajax"><a href="#ajax" class="header-anchor">#</a> Ajax</h1> <p>通过XMLHttpRequest对象向服务器发送异步请求，获取服务器返回的数据，操作dom更新页面</p> <h3 id="xmlhttprequest对象"><a href="#xmlhttprequest对象" class="header-anchor">#</a> XMLHttpRequest对象</h3> <p>abort():如果请求已经发送，则停止当前请求。</p> <p>getAllResponseHeaders():获取所有HTTP请求的响应头部，作为键值返回，如果没有收到响应，则返回null</p> <p>getResponseHeader(&quot;key&quot;)函数:获取指定key的HTTP响应头，如果没有收到响应或者响应中不存在key对象
的报头，则返回null,</p> <ol start="4"><li>open(&quot;method&quot;,&quot;URL&quot;,[asyncFlag],&quot;userName&quot;.[&quot;password&quot;])函数:
建立对服务器的调用。
5中专国器
。method参数表示请求方式，可以为GET, POST或者PUT.
。URL参数表示请求的路径，可以使相对路径，也可以时绝对路径。
。后面3个是可选参数，分别表示是否异步，用户名，密码，其中asyncFlag = true表示异步，asyncFlag =
false表示同步，默认值为true,</li> <li>send(content)函数:向服务器发送请求。</li> <li>setRequestHeader(key,value)函数:设置请求头中属性为key的值为value,在设置请求头之前需要先调用
open(函数，设置header将随着send()函数一起发送。</li></ol></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vpTST/H5C3JS/H5C3.html" class="prev">
            H5C3
          </a></span> <!----></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#变量" class="sidebar-link reco-side-变量" data-v-cb1513f6>变量</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#执行上下文" class="sidebar-link reco-side-执行上下文" data-v-cb1513f6>执行上下文</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#作用域链" class="sidebar-link reco-side-作用域链" data-v-cb1513f6>作用域链</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#全局上下文" class="sidebar-link reco-side-全局上下文" data-v-cb1513f6>全局上下文</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#函数上下文" class="sidebar-link reco-side-函数上下文" data-v-cb1513f6>函数上下文</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#作用域" class="sidebar-link reco-side-作用域" data-v-cb1513f6>作用域</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#静态词法作用域-动态作用域" class="sidebar-link reco-side-静态词法作用域-动态作用域" data-v-cb1513f6>静态词法作用域／动态作用域</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#array" class="sidebar-link reco-side-array" data-v-cb1513f6>array</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#map" class="sidebar-link reco-side-map" data-v-cb1513f6>Map</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#set" class="sidebar-link reco-side-set" data-v-cb1513f6>set</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#数字类型" class="sidebar-link reco-side-数字类型" data-v-cb1513f6>数字类型</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#基本创建方法" class="sidebar-link reco-side-基本创建方法" data-v-cb1513f6>基本创建方法</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#对象属性" class="sidebar-link reco-side-对象属性" data-v-cb1513f6>对象属性</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#对象属性特征描述" class="sidebar-link reco-side-对象属性特征描述" data-v-cb1513f6>对象属性特征描述</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#数据属性" class="sidebar-link reco-side-数据属性" data-v-cb1513f6>数据属性</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#访问器属性" class="sidebar-link reco-side-访问器属性" data-v-cb1513f6>访问器属性</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#设计模式创建对象" class="sidebar-link reco-side-设计模式创建对象" data-v-cb1513f6>设计模式创建对象</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#工厂模式" class="sidebar-link reco-side-工厂模式" data-v-cb1513f6>工厂模式</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#基于动态原型创建对象" class="sidebar-link reco-side-基于动态原型创建对象" data-v-cb1513f6>基于动态原型创建对象</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#原型、原型链" class="sidebar-link reco-side-原型、原型链" data-v-cb1513f6>原型、原型链</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#创建函数" class="sidebar-link reco-side-创建函数" data-v-cb1513f6>创建函数</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#this指向" class="sidebar-link reco-side-this指向" data-v-cb1513f6>this指向</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#具体例子" class="sidebar-link reco-side-具体例子" data-v-cb1513f6>具体例子</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#函数方法" class="sidebar-link reco-side-函数方法" data-v-cb1513f6>函数方法</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#call-apply-bind" class="sidebar-link reco-side-call-apply-bind" data-v-cb1513f6>call() apply() bind()</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#闭包" class="sidebar-link reco-side-闭包" data-v-cb1513f6>闭包</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#回调函数callback" class="sidebar-link reco-side-回调函数callback" data-v-cb1513f6>回调函数callback</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#call-apply" class="sidebar-link reco-side-call-apply" data-v-cb1513f6>call()  apply()</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#插入标签" class="sidebar-link reco-side-插入标签" data-v-cb1513f6>插入标签</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#事件" class="sidebar-link reco-side-事件" data-v-cb1513f6>事件</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#事件对象" class="sidebar-link reco-side-事件对象" data-v-cb1513f6>事件对象</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#事件流" class="sidebar-link reco-side-事件流" data-v-cb1513f6>事件流</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#事件处理" class="sidebar-link reco-side-事件处理" data-v-cb1513f6>事件处理</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#event对象" class="sidebar-link reco-side-event对象" data-v-cb1513f6>Event对象</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#事件循环" class="sidebar-link reco-side-事件循环" data-v-cb1513f6>事件循环</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#拖动事件" class="sidebar-link reco-side-拖动事件" data-v-cb1513f6>拖动事件</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#var-let-const" class="sidebar-link reco-side-var-let-const" data-v-cb1513f6>var\let\const</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#箭头函数" class="sidebar-link reco-side-箭头函数" data-v-cb1513f6>箭头函数</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#spread语法" class="sidebar-link reco-side-spread语法" data-v-cb1513f6>spread语法</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#promise" class="sidebar-link reco-side-promise" data-v-cb1513f6>promise</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#同步、异步" class="sidebar-link reco-side-同步、异步" data-v-cb1513f6>同步、异步</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#柯里化-currying" class="sidebar-link reco-side-柯里化-currying" data-v-cb1513f6>柯里化（Currying）???</a></li><li class="level-2" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#异步编程-2" class="sidebar-link reco-side-异步编程-2" data-v-cb1513f6>异步编程</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#单线程" class="sidebar-link reco-side-单线程" data-v-cb1513f6>单线程</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#同步与异步" class="sidebar-link reco-side-同步与异步" data-v-cb1513f6>同步与异步</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#如何进行异步编程" class="sidebar-link reco-side-如何进行异步编程" data-v-cb1513f6>如何进行异步编程</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#math" class="sidebar-link reco-side-math" data-v-cb1513f6>Math</a></li><li class="level-3" data-v-cb1513f6><a href="/vpTST/H5C3JS/JS.html#xmlhttprequest对象" class="sidebar-link reco-side-xmlhttprequest对象" data-v-cb1513f6>XMLHttpRequest对象</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/vpTST/assets/js/app.964cbb8c.js" defer></script><script src="/vpTST/assets/js/3.86ab0857.js" defer></script><script src="/vpTST/assets/js/1.84cb0844.js" defer></script><script src="/vpTST/assets/js/9.8592346e.js" defer></script>
  </body>
</html>
